// zod will be used for the user-input validation
// Working of the zod
// 1. first define the scheme 
// 2. use the schema with the "parse" method to verify your variable passes the test. if valid => zod scheme.parse throws deep copy of the input that you provided else will throw zodError instance (kind of error) with information about the error. this method should be used inside the try catch block so that catch block catches the zodError instance (all errors will be present in error.issues)
// 3. If does not want to use the try catch then use "safeParse" method of schema, if valid => {success: true, data: actualData on which checking happens}, if failure => {success: false, error: zodError}

const express = require("express");
const z = require("zod");
const app = express();
const port = 3000;
const storage = [];
let autoGeneratedId = 0;

app.use(express.json()); // middle-ware for parsing the body when it will be JSON format, if it does not comes in valid JSON format then the global-catches middleware will handle this, either the user send no body (then treated as empty object -> {}) or send correct one

// suppose our backend only support todo for single user others cannot hit => have to do authentication (do you belong to the system or not)

// doing user-validation for todo backend
// user will send todo that will have description, title, completed
const todoSchema = z.object({
    title: z.string(),
    description: z.string(),
    completed: z.boolean()
}) // define the shape of the object


app.post("/todos", function(req, res) {
    // using parse method schema hence have to encapsulate the code inside try catch
    let todo = req.body.todo;
    try {
        const result = todoSchema.parse(todo); // if valid todo => throws the deep copy of that
        result.id = autoGeneratedId;
        autoGeneratedId++;

        storage.push(result);

        res.status(200).json({
            id: result.id
        })
    } catch(err) {
        // since there can be multiple error we want to detect the zodError
        if(err instanceof z.ZodError) {
            console.log(err);
            console.log(err.issues); // all the issues related to user-validation will come here [{code: "", expected: "", recieved: "", path: [], message: ""}]
            res.status(411).json(err.issues); 
            return
        }
        // this is my old way to handle the error
        //res.status(err.statusCode).send(err.message);
        //  but since we have implemented global catches we can now throw the error
        throw err;
    }
})

// implementing post with safeParse
app.post("/todos/safeParse", function(req, res) {
    const myTodoSchema = z.object({
        title: z.string(),
        description: z.string(),
        completed: z.boolean()
    }) // define the schema globally

    const todo = req.body.todo;

    const result = myTodoSchema.safeParse(todo); // -> result > {success: false / true, error: zodError if success false, data: copy}
    if(!result.success) {
        console.log(result.error); // result.error -> zodError instance object which contains all issues as result.error.issues (just like the scheme.parse() method ) + name as "zodError"
        res.status(411).json({
            error: result.error.issues
        })
        return
    }

    result.data.id = autoGeneratedId;
    autoGeneratedId++;

    storage.push(result.data);

    res.status(200).json({
        id: result.data.id,
    })
})




// global-catches -> middlewares that mention at then end to encounter error happens in any route-handler
app.use(function(err, req, res, next) {
    if(err) {
        console.log(err);
        res.status(500).json({
            msg: "Something up with our backend server! Sorry ðŸ˜ž"
        })
        return
    }
    // means no error but matches with every route-handler because it does not have any route, will have to call the route-handler for the not found
    next();
})

// route-handler for encoutering if request does not matches with any route-handler
app.use(function(req, res, next) {
    res.status(404).json({
        msg: "Route not found"
    })
})

app.listen(port);

// both the error object in safeParse and parse are same, belongs to the instance zodError with same properties as issues (array of all issue) + name

// parse method directly provide us instance of the zodError as {issues: [], name: "zodError"}
// safeParse method provides zodError if success: false, as result.error -> zodError with properties as name and issues