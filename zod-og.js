// zod will be used for the user-input validation
// Working of the zod
// 1. first define the scheme 
// 2. use the schema with the "parse" method to verify your variable passes the test. if valid => zod scheme.parse throws deep copy of the input that you provided else will throw zodError instance (kind of error) with information about the error. this method should be used inside the try catch block so that catch block catches the zodError instance (all errors will be present in error.issues)
// 3. If does not want to use the try catch then use "safeParse" method of schema, if valid => {success: true, data: actualData on which checking happens}, if failure => {success: false, error: zodError}

const express = require("express");
const z = require("zod");
const app = express();
const port = 3000;
const storage = [];
const autoGeneratedId = 0;

app.use(express.json()); // middle-ware for parsing the body when it will be JSON format

// suppose our backend only support todo for single user others cannot hit => have to do authentication (do you belong to the system or not)

// doing user-validation for todo backend
// user will send todo that will have description, title, completed
const todoSchema = z.object({
    title: z.string(),
    description: z.string(),
    completed: z.boolean()
}) // define the shape of the object


app.post("/todos", function(req, res) {
    // using parse method schema hence have to encapsulate the code inside try catch
    let todo = req.body.todo;
    try {
        const result = todoSchema.parse(todo); // if valid todo => throws the deep copy of that
        result.id = autoGeneratedId;
        autoGeneratedId++;

        storage.push(result);

        res.status(200).json({
            id: result.id
        })
    } catch(err) {
        // since there can be multiple error we want to detect the zodError
        if(err instanceof z.ZodError) {
            console.log(err.issues); // all the issues related to user-validation will come here
            res.status(411).json(err.issues);
            return
        }
        // this is my old way to handle the error
        res.status(err.statusCode).send(err.message);
    }
})




// global-catches -> middlewares that mention at then end to encounter error happens in any route-handler
app.use(function(err, req, res, next) {
    if(err) {
        res.status(500).json({
            msg: "Something up with our backend server! Sorry ðŸ˜ž"
        })
        return
    }
    // means no error but matches with every route-handler because it does not have any route, will have to call the route-handler for the not found
    next();
})

// route-handler for encoutering if request does not matches with any route-handler
app.use(function(req, res, next) {
    res.status(404).json({
        msg: "Route not found"
    })
})

app.listen(port);